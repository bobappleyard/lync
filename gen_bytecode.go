// Code generated by github.com/bobappleyard/lync/util/bytecode DO NOT EDIT
package lync
import "github.com/bobappleyard/lync/util/format"


type BytecodeEncoder struct {
	Buf []byte
}


func (e *BytecodeEncoder) Block(argc byte, varc byte, entry CodeRef) error {
	after, err := format.MarshalInto(e.Buf, uint(0))
	if err != nil {
		return err
	}
	
	after, err = format.MarshalInto(after, argc)
	if err != nil {
		return err
	}
	
	after, err = format.MarshalInto(after, varc)
	if err != nil {
		return err
	}
	
	after, err = format.MarshalInto(after, entry)
	if err != nil {
		return err
	}
	
	e.Buf = after
	return nil
}

func (e *BytecodeEncoder) Branch(ref CodeRef) error {
	after, err := format.MarshalInto(e.Buf, uint(1))
	if err != nil {
		return err
	}
	
	after, err = format.MarshalInto(after, ref)
	if err != nil {
		return err
	}
	
	e.Buf = after
	return nil
}

func (e *BytecodeEncoder) Call(method MethodID, argc byte) error {
	after, err := format.MarshalInto(e.Buf, uint(2))
	if err != nil {
		return err
	}
	
	after, err = format.MarshalInto(after, method)
	if err != nil {
		return err
	}
	
	after, err = format.MarshalInto(after, argc)
	if err != nil {
		return err
	}
	
	e.Buf = after
	return nil
}

func (e *BytecodeEncoder) CallTail(method MethodID, argc byte) error {
	after, err := format.MarshalInto(e.Buf, uint(3))
	if err != nil {
		return err
	}
	
	after, err = format.MarshalInto(after, method)
	if err != nil {
		return err
	}
	
	after, err = format.MarshalInto(after, argc)
	if err != nil {
		return err
	}
	
	e.Buf = after
	return nil
}

func (e *BytecodeEncoder) Float(value float64) error {
	after, err := format.MarshalInto(e.Buf, uint(4))
	if err != nil {
		return err
	}
	
	after, err = format.MarshalInto(after, value)
	if err != nil {
		return err
	}
	
	e.Buf = after
	return nil
}

func (e *BytecodeEncoder) Int(value int) error {
	after, err := format.MarshalInto(e.Buf, uint(5))
	if err != nil {
		return err
	}
	
	after, err = format.MarshalInto(after, value)
	if err != nil {
		return err
	}
	
	e.Buf = after
	return nil
}

func (e *BytecodeEncoder) Jump(ref CodeRef) error {
	after, err := format.MarshalInto(e.Buf, uint(6))
	if err != nil {
		return err
	}
	
	after, err = format.MarshalInto(after, ref)
	if err != nil {
		return err
	}
	
	e.Buf = after
	return nil
}

func (e *BytecodeEncoder) Load(r Register) error {
	after, err := format.MarshalInto(e.Buf, uint(7))
	if err != nil {
		return err
	}
	
	after, err = format.MarshalInto(after, r)
	if err != nil {
		return err
	}
	
	e.Buf = after
	return nil
}

func (e *BytecodeEncoder) Name(id MethodID) error {
	after, err := format.MarshalInto(e.Buf, uint(8))
	if err != nil {
		return err
	}
	
	after, err = format.MarshalInto(after, id)
	if err != nil {
		return err
	}
	
	e.Buf = after
	return nil
}

func (e *BytecodeEncoder) Return() error {
	after, err := format.MarshalInto(e.Buf, uint(9))
	if err != nil {
		return err
	}
	
	e.Buf = after
	return nil
}

func (e *BytecodeEncoder) Store(r Register) error {
	after, err := format.MarshalInto(e.Buf, uint(10))
	if err != nil {
		return err
	}
	
	after, err = format.MarshalInto(after, r)
	if err != nil {
		return err
	}
	
	e.Buf = after
	return nil
}

func (e *BytecodeEncoder) String(value string) error {
	after, err := format.MarshalInto(e.Buf, uint(11))
	if err != nil {
		return err
	}
	
	after, err = format.MarshalInto(after, value)
	if err != nil {
		return err
	}
	
	e.Buf = after
	return nil
}

func (e *BytecodeEncoder) Unit() error {
	after, err := format.MarshalInto(e.Buf, uint(12))
	if err != nil {
		return err
	}
	
	e.Buf = after
	return nil
}
type BytecodeDecoder struct {
	Code []byte
	Pos int
	Impl Bytecode
}

func (d *BytecodeDecoder) Step() (err error) {
	switch d.Code[d.Pos] {
	
	case 0:
		b := d.Code[d.Pos+1:]
		
		var argc byte
		if b, err = format.UnmarshalFrom(b, &argc); err != nil {
			return err
		}
		
		var varc byte
		if b, err = format.UnmarshalFrom(b, &varc); err != nil {
			return err
		}
		
		var entry CodeRef
		if b, err = format.UnmarshalFrom(b, &entry); err != nil {
			return err
		}
		
		d.Pos = len(d.Code) - len(b)
		d.Impl.Block(argc,varc,entry,)
	
	case 1:
		b := d.Code[d.Pos+1:]
		
		var ref CodeRef
		if b, err = format.UnmarshalFrom(b, &ref); err != nil {
			return err
		}
		
		d.Pos = len(d.Code) - len(b)
		d.Impl.Branch(ref,)
	
	case 2:
		b := d.Code[d.Pos+1:]
		
		var method MethodID
		if b, err = format.UnmarshalFrom(b, &method); err != nil {
			return err
		}
		
		var argc byte
		if b, err = format.UnmarshalFrom(b, &argc); err != nil {
			return err
		}
		
		d.Pos = len(d.Code) - len(b)
		d.Impl.Call(method,argc,)
	
	case 3:
		b := d.Code[d.Pos+1:]
		
		var method MethodID
		if b, err = format.UnmarshalFrom(b, &method); err != nil {
			return err
		}
		
		var argc byte
		if b, err = format.UnmarshalFrom(b, &argc); err != nil {
			return err
		}
		
		d.Pos = len(d.Code) - len(b)
		d.Impl.CallTail(method,argc,)
	
	case 4:
		b := d.Code[d.Pos+1:]
		
		var value float64
		if b, err = format.UnmarshalFrom(b, &value); err != nil {
			return err
		}
		
		d.Pos = len(d.Code) - len(b)
		d.Impl.Float(value,)
	
	case 5:
		b := d.Code[d.Pos+1:]
		
		var value int
		if b, err = format.UnmarshalFrom(b, &value); err != nil {
			return err
		}
		
		d.Pos = len(d.Code) - len(b)
		d.Impl.Int(value,)
	
	case 6:
		b := d.Code[d.Pos+1:]
		
		var ref CodeRef
		if b, err = format.UnmarshalFrom(b, &ref); err != nil {
			return err
		}
		
		d.Pos = len(d.Code) - len(b)
		d.Impl.Jump(ref,)
	
	case 7:
		b := d.Code[d.Pos+1:]
		
		var r Register
		if b, err = format.UnmarshalFrom(b, &r); err != nil {
			return err
		}
		
		d.Pos = len(d.Code) - len(b)
		d.Impl.Load(r,)
	
	case 8:
		b := d.Code[d.Pos+1:]
		
		var id MethodID
		if b, err = format.UnmarshalFrom(b, &id); err != nil {
			return err
		}
		
		d.Pos = len(d.Code) - len(b)
		d.Impl.Name(id,)
	
	case 9:
		b := d.Code[d.Pos+1:]
		
		d.Pos = len(d.Code) - len(b)
		d.Impl.Return()
	
	case 10:
		b := d.Code[d.Pos+1:]
		
		var r Register
		if b, err = format.UnmarshalFrom(b, &r); err != nil {
			return err
		}
		
		d.Pos = len(d.Code) - len(b)
		d.Impl.Store(r,)
	
	case 11:
		b := d.Code[d.Pos+1:]
		
		var value string
		if b, err = format.UnmarshalFrom(b, &value); err != nil {
			return err
		}
		
		d.Pos = len(d.Code) - len(b)
		d.Impl.String(value,)
	
	case 12:
		b := d.Code[d.Pos+1:]
		
		d.Pos = len(d.Code) - len(b)
		d.Impl.Unit()
	
	default:
		panic("unknown bytecode")
	}

	return nil
}